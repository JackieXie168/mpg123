<!--#include file="header.html" -->
	<title>mpg123, Fast MP3 Player for Linux and UNIX systems</title>
	<meta name="keywords" content="mp3 linux player decoder mpg123 mp2 mp1 mpeg audio solaris hpux layer3 layer2 layer1 aix freebsd bsdos sgi ultrix os2 netbsd mint windows esd 3dnow pentium optimized nas alpha dec sparc alsa oss mips ppc java sunos fast free source unix cool frontend" />
	<meta name="robots" content="INDEX,FOLLOW" />
</head>
<body>
<!--#include file="linkbar.html" -->
<h1>mpg123 - Fast console MPEG Audio Player and decoder library</h1>
<p>
The mpg123 distribution contains a
real time MPEG 1.0/2.0/2.5 audio player/decoder
for layers 1,2 and 3 (most commonly MPEG 1.0 layer 3 aka MP3),
as well as re-usable decoding and output <a href="/api/">libraries</a>.
Among others, it works on GNU/Linux, MacOSX, the BSDs, Solaris,
AIX, HPUX, SGI Irix, OS/2 and Cygwin or plain MS Windows
(not all more exotic platforms tested regularily, but patches welcome).
You may jump to the non-exhaustive <a href="features.shtml">list of features</a>.
</p>
<p>
It is free software licensed under LGPL 2.1 .
</p>
<p>
Note that nowadays, the <strong>mpg123 decoder</strong> core can work with
<strong>floating point or integer math</strong> and with some
tuning between accuracy and performance at build-time,
using assembly optimizations for several platforms,
depending on your build configuration. There is detection and
selection of assembly optimisations on x86, x86-64, and ARM at
program runtime.
It's fast, it's high-quality. Just use it;-)
</p>

<h2>Top News</h2>
<!--#include virtual="cgi-bin/news.cgi?top" -->

<h2><a id="compliance"></a>ISO MPEG compliance</h2>
<p>This is a rough log of an automated compliance test on the mpg123 webserver (Xeon E3, GNU/Linux),
using the test bitstreams from the ISO MPEG reference set.
At least the floating point output should really be close enough to the reference.</p>
<p>
	Regarding the method: This is comparing mpg123's output (with gapless code deactivated) from reference bitstreams to the reference output.
	A simple RMS error measure is employed, relative to full scale, just summing over mono or stereo data indiscriminently.
	This is my interpretation of the rules... maximum allowed RMS=8.80967e-06, maximum signal difference 6.10352e-05.
</p>
<pre class="plain">
<!--#include file="compliance.log" -->
</pre>
<p>
	Depending on what integer quality mode you choose at compile time (and the decoder in use), the 16bit output can vary between PASS and LIMITED for fully or limited accuracy compliance.
	But keep in mind:
	For the integer output, you have to give +-1 for rounding... that's what I append to any integer number read from some measurement device anyway, by default.
	That minimum possible deviation already brings the output close (or over) the border of full compliance... that really does not mean that the output sounds bad!
	It shall be noted that a measure to improve subjective quality, namely the dithering before rounding to integers, can also increase the theoretical decoding error.
</p>
<p>
	In the end, RMS values in the order of 10 to the power of -5 should sound just fine.
	To get 16bit output to PASS, you usually need to enable proper rounding using the
	<span class="code">--enable-int-quality</span> configure flag.
	It is not on by default because it mostly (yeah, there are odd cases) needs somewhat more CPU time and the simple truncation is fine for most people.
	Note that mpg123 does have a rounding method using the specific IEEE754 floating point
	format, selected at build-time, which seems to be nearly as fast as simple truncation
	on x86-64 hardware. So, <span class="code">--enable-int-quality</span> might be a
	no-brainer on those systems if using the generic C decoder.
	But then, there are the specific assembly routines (SSE, AVX), where the difference between
	accurate and non-accurate integer conversion can still amount to 20&nbsp;% runtime increase
	(measured on a Core2Duo P8600 with GCC 5.3.0).
</p>
<p>
	For comparisong with other decoders (as well as older incarnations of the mpg123 engine), have a read of
	the <a href="http://www.underbit.com/resources/mpeg/audio/compliance/">Underbit compliance tests</a>.
	Actually, my testing method follows that example, including their quoting of ISO MPEG rules.
</p>

<h2><a id="regression"></a>Regression tests</h2>
<p>
This is output from the rudimentary regression test suite (which should eventually merge several approaches we had on testing in the past), working on the periodic snapshot:
</p>
<pre class="plain">
<!--#include file="regression.log" -->
</pre>

<h2>Needed computing power</h2>
<p>A test (GNU/Linux OS) with 0.60-beta2 showed 3&nbsp;% to 4&nbsp;% CPU
usage on decoding high quality VBR MP3 with a pentiumII laptop with 366MHz, while a pentium 100MHz can easily handle two mpg123 instances in realtime (plus the mixing daemon that works on decoded data).
 Well, and more recently,
	A Core2Duo P8600 core can do 500 times realtime decoding (a track
	nearly five minutes long decoded in half a second).
</p>
<p>
Also, we have reports from such devices as nintendo DS or Sony PSP, or various embedded systems... 
</p>
<h3>Michael said once upon a time</h3>
<p>
	Plays Layer 3 in stereo on an AMD-486-120Mhz or (of course) a faster machine.
</p>
<p>
	Just for info: mpg123 plays an average 128bps stream, with about 66%
	in full quality on an AMD 486-133MHz machine.
</p>
<!--#include file="footer.html" -->
