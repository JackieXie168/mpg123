    ________________________________________________________________________
   /                                                                        \
  |   Let's analyze how the buffer stuff works to put it into proper form    |
  |   for libout123!                                                         |
   \________________________________________________________________________/

1. How does the buffer communication work?
==========================================

There are these API calls:

- buffer_start()
	if(buffermem->justwait)
	xfermem_putcmd(buffermem->fd[XF_WRITER], XF_CMD_WAKEUP);

- buffer_stop()
	buffermem->justwait = TRUE;
	buffer_sig(SIGINT, TRUE);

- buffer_reset()
	buffer_sig(SIGUSR1, TRUE);

- buffer_resync()
	if(buffermem->justwait)
	{
		buffermem->wakeme[XF_WRITER] = TRUE;
		xfermem_putcmd(buffermem->fd[XF_WRITER], XF_CMD_RESYNC);
		xfermem_getcmd(buffermem->fd[XF_WRITER], TRUE);
	}
	else buffer_sig(SIGINT, TRUE);

- plain_buffer_resync()
	buffer_sig(SIGINT, FALSE);

- buffer_end()
	xfermem_putcmd(buffermem->fd[XF_WRITER], rude ? XF_CMD_ABORT : XF_CMD_TERMINATE);

Also, there is direct use of the xfermem API:

- xfermem_write(buffermem, bytes, count)
  to push data to buffer

- xfermem_get_usedspace(buffermem)
  to get bytes still in buffer (not written to audio output)

- xfermem_block(XF_WRITER, buffermem)
  for synchronization / messaging to writer (buffer client)

- xfermem_putcmd(buffermem->fd[XF_WRITER], cmd)
  to give comands to buffer

- xfermem_getcmd(buffermem->fd[XF_WRITER], TRUE (FALSE?))
  to get commands/response from buffer?

I probably should clear that up first.

1.1 xfermem
-----------

Quoting Oliver:

	This is a stand-alone module which implements a unidirectional,
	fast pipe using mmap().  Its primary use is to transfer large
	amounts of data from a parent process to its child process,
	with a buffer in between which decouples blocking conditions
	on both sides.  Control information is transferred between the
	processes through a socketpair.

The actual shared memory is implemented using anonymous mmap(),
mmap() of /dev/zero, or via traditional System V memory. This reminds
me that there are some code paths that are not excercised often.
I should introduce (runtime?) switch to be able to test each variant.
On the other hand, the sysVshm API is not that rapidly changing.

Anyhow, the point is that we have xfermem structure and buffer memory
shared between main and buffer process, by whatever means. Commands
are exchanged via the socket pair xfermem->fd[XF_WRITER] and
xfermem->fd[XF_READER].

- xfermem_init(xf, bufsize, msize, skipbuf)
  to intialize the pipe, msize and skipbuf equal to zero for mpg123 use

- xfermem_done(xf)
  to free the shared memory, not bothering with cleaning up the sockets
  Should I change that? The reader process exists before clearing the
  data structure, but the writer process keeps the socket open ...
  I think I should introduce xfermem_exit_writer() and xfermem_exit_reader(),

- xfermem_init_writer() / xfermem_init_reader()
  to close the respective other end of the socket pair

- xfermem_get_freespace()
  to return space available for writing

- xfermem_get_usedspace()
  to return space filled with data, waiting to be consumed

- xfermem_getcmd(fd, block)
  to ... well wait for a one-byte command code on the given file descriptor,
  blocking or non-blocking.

- xfermem_putcmd(fd, cmd)
  to send a command to the other end with the fd on this side

- xfermem_block(rw, xf)
  to synchronize ... needs some thought
  The value of rw is XF_READER or XF_WRITER, xf->wakeme[rw] is set, if the
  other end has set xf->wakeme[1-rw], it gets a wakeup call
  (xfermem_putcmd(xf->fd[rw], XF_CMD_WAKEUP)) and this end waits for a sign
  (xfermem_getcmd(xf->fd[rw], TRUE)), clearing cf->wakeme[rw] after that.
  Classic synchronization.

- xfermem_sigblock(rw, xf, pid, sig)
  to signal the other process by given pid and wait for a wakeup call as
  response
  I added that to fix bug 2796802 in the year 2009. Hm. Well, it is
  necessary to interrupt the buffer process if it is not currently
  waiting for a command.

- xfermem_write(xf, buffer, bytes)
  to wait until enough space is free, then copy over the bytes
  A bonus is to wakeup the reader process if it has xf->wakeme set.

That's it. It's a shared ringbuffer with some synchronization and
messaging.

1.2 buffer API explained
------------------------

Now it's time to decipher what the buffer API calls do. The buffer works
on an instance of xfermem which is called buffermem, but I'll refer to it
using xf as before.

- buffer_start()
  to send XF_CMD_WAKEUP to the buffer in case it is waiting (xf->justwait)
  Why is there xf->justwait in addition to xf->wakeme? Apparently to set
  it from the reader in buffer_stop(). It's the hack to be able to use
  SIGINT for two messages.

- buffer_stop()
  to interrupt the buffer and send it into waiting mode
  This sets xf->justwait and then signals SIGINT, waiting for the buffer
  to acknowledge. The buffer process sets intflag and, on the next occasion
  in the main loop, drains its command queue, sends wakeup to the writer
  desired. It then waits for commands.

- buffer_reset()
  to interrupt the buffer, causing it to reopen the audio device, possibly
  with new settings
  This also discards all data currently in the buffer (presumably in
  incompatible audio format/encoding) and sends a wakeup to the writer
  if desired. Flushing of audio device happens first.

- buffer_resync()
  to send XF_CMD_RESYNC directly or indirectly (plain SIGINT) to the buffer
  The buffer flushes the audio and discards all buffer data, wakes writer
  afterwards.

- plain_buffer_resync()
  to signal a resync (SIGINT) to the buffer without waiting for the result
  This disregards the case 

- buffer_end()
  to either send XF_CMD_ABORT (end processing right away) or XF_CMD_TERMINATE
  In either case, the buffer only gets this as normal command, not per signal,
  though I have to think about what the signalling stuff really adds to the
  picture. Damn! It's designed to abort flush_output(), or rather
  ao->write(). I twarted that some time ago by making flush_output() resilient.
  I need to revert that; the buffer code should not call flush_output.
  Instead, it should just call ao->write(). Being interrupted does not matter
  much since the buffer continues to write on the next iteration anyway.
  But then, I also need to make the buffer resilient about ao->write()
  being interrupted. It is already checking for SIGINT / SIGUSR1, but
  I uttered something about SIGSTOP / SIGCONT. I need to revisit that
  behaviour. Does SIGSTOP really cause audio output writes to return early?

1.3 Analysis
------------

Well, there we are now. Some questions popped, specifically about the use
of signals.

- 1. Is the use of signals SIGINT / SIGUSR1 really appropriate?

- 2. What do SIGSTOP / SIGCONT do to ao->flush()?

The idea of the signals should be that the buffer reacts to them immediately
instead of finishing a write to the audio device. I don't see another point.
I may want to revisit which actions really demand that kind of reaction.
Currently, it's three of them:

- stop operation (justwait)
- resync (discarding buffered data)
- reset (discard data, re-open audio device)

That list looks sensible.

Now, I damanged that logic in 2007 with commit 1278. I put flush_output() also
into the buffer, which broke the immediate reaction after a signal. Now the
question is: Do we really care about that immediate reaction? Only if the
hardware buffer happens to be large, or because it is blocking for some
reason. Hm, the latter could be annoying.

In the current state, the signals could be replaced with normal messages and
nothing would change. But I will change that and repair the buffer reaction
again!

The second question about SIGSTOP / SIGCONT doesn't really matter in this
context. The normal flush_output() indeed should loop to make things work,
as that is the semantics of the non-buffered output. It returns after it
is finised. It may be a question if I want to introduce that in the libout123
API, too. I guess there should be a parameter or separate API call to
decide if the writing/flushing should return after being interrupted or
only after it wrote the given data. There are use cases for both.

But still, I have to check the behaviour with SIGSTOP. How does ALSA handle
it? Heh, a search for that returns this:

	https://sourceforge.net/p/mpg123/bugs/37/

	with alsa and mpg123-0.65, when I press ^Z and then
	fg after some time, there is evil squeaky sound --
	the longer the pause, the longer the squeaky sound.

I keep stumbling over my own tracks in the internet;-) Of course, this bug
wasn't always numbered 37, that's sf.net's reboot. Also, I don't find
an attachment, but a patch is referenced by Clemens. Did sf.net kill that? At
least I mentioned the revision: 637. Yes, that introduces some EINTR handling.

Another interesting data point:

	http://compgroups.net/comp.linux.development.system/sigstop-and-interrupted-system/2865328

	This is somewhat debatable.  What the OP is talking about here is
	behaviour that occurs *in the absence* of a signal handler.  On almost
	every other Unix, in this case, the signal is not visible to the
	application; that is, the system call is automatically resumed upon
	receipt of SIGCONT.

	The behaviour of Linux is idiosyncratic: on Linux, a stop signal +
	SIGCONT causes certain system calls to fail with EINTR, even in the
	absence of signal handlers.  In my reading of SUSv3, this ishould not
	happen.  No other contemporary Unix implementation that I know of (and
	I've tested many) does this.  (I'm told that historically one oether
	implementation -- I think it was AIX -- did this, but does not do it
	nowadays, since it was deemed to be non-standard.)

	Cheers,

	Michael

So it seems that, indeed, I need the outer loop over ao->flush to cope
with SIGSTOP / SIGCONT. I didn't add it just for fun. If I remove that
loop from the buffer, it needs to be aware that less written bytes that
given does not have to mean that an error occured. It could be
SIGSTOP+SIGCONT. And since the EINTR is handled inside the audio outputs,
the details are hidden and the buffer just has to assume that if the
number of written bytes is >= 0, that everything is OK so far.
