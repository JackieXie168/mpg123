Currently, mpg123 queries audio output devices for supported formats and rates and tries to match that with frame properties and user requests.

There are three players:

1. (changing) mpeg frame properties: channels, rate
2. user requests: channel, fixed rate
3. audio device support

The mpeg frame does not care about sample format (16 or 8 bits, (un)signed), but it knows a channel count and sample rate.
Then, the user can force mono (left, right, mix) or stereo and downsampling, as well as a fixed rate.
Hm, let's have a read of the relevant code from mpg123.c:

void prepare_audioinfo(struct frame *fr, struct audio_info_struct *nai)
{
	long newrate = frame_freq(fr)>>(fr->p.down_sample);
	fr->down_sample = fr->p.down_sample;
	if(!audio_fit_capabilities(nai, fr->stereo, newrate, &fr->p)) safe_exit(1);
}

That takes the native sample frequency and applies downsampling, then tries to find valid settings for the hardware.
Now, this is called from within this:

		if(fr->header_change > 1 || init) {
			old_rate = ai.rate;
			old_format = ai.format;
			old_channels = ai.channels;

			newrate = frame_freq(fr)>>(fr->p.down_sample);
			prepare_audioinfo(fr, &ai);
			if(param.verbose > 1) fprintf(stderr, "Note: audio output rate = %li\n", ai.rate);

			/* check, whether the fitter set our proposed rate */
			if(ai.rate != newrate) {
				if(ai.rate == (newrate>>1) )
					fr->down_sample++;
				else if(ai.rate == (newrate>>2) )
					fr->down_sample+=2;
				else {
					fr->down_sample = 3;
					fprintf(stderr,"Warning, flexible rate not heavily tested!\n");
				}
				if(fr->down_sample > 3)
					fr->down_sample = 3;
			}

			switch(fr->down_sample) {
				case 0:
				case 1:
				case 2:
					fr->down_sample_sblimit = SBLIMIT>>(fr->down_sample);
					break;
				case 3:
					{
						long n = frame_freq(fr);
                                                long m = ai.rate;

						if(!synth_ntom_set_step(fr, n, m)) return 0;

						if(n>m) {
							fr->down_sample_sblimit = SBLIMIT * m;
							fr->down_sample_sblimit /= n;
						}
						else {
							fr->down_sample_sblimit = SBLIMIT;
						}
					}
					break;
			}

			init_output();
			if(ai.rate != old_rate || ai.channels != old_channels ||
			   ai.format != old_format || param.force_reopen) {
				if(!(fr->p.flags & MPG123_FORCE_MONO)) {
					if(ai.channels == 1)
						fr->single = SINGLE_MIX;
					else
						fr->single = SINGLE_STEREO;
				}
				else
					fr->single = (fr->p.flags & MPG123_FORCE_MONO)-1;

				frame_outformat(fr, ai.format, ai.channels, ai.rate);
#ifdef GAPLESS
				if(fr->p.flags & MPG123_GAPLESS && (fr->lay == 3)) frame_gapless_bytify(fr);
#endif
				if(set_synth_functions(fr) != 0) safe_exit(1);
				init_layer3_stuff(fr);
				init_layer2_stuff(fr);
				reset_audio();
				if(param.verbose) {
					if(fr->down_sample == 3) {
						long n = frame_freq(fr);
						long m = ai.rate;
						if(n > m) {
							fprintf(stderr,"Audio: %2.4f:1 conversion,",(float)n/(float)m);
						}
						else {
							fprintf(stderr,"Audio: 1:%2.4f conversion,",(float)m/(float)n);
						}
					}
					else {
						fprintf(stderr,"Audio: %ld:1 conversion,",(long)pow(2.0,fr->down_sample));
					}
 					fprintf(stderr," rate: %ld, encoding: %s, channels: %d\n",ai.rate,audio_encoding_name(ai.format),ai.channels);
				}
			}
			if (intflag)
				return 1;
		}


Let's summarize:
If header changed (significantly) or we have the first one, start messing with output.
First, try to find a valid output config with the downsampled rate and the frame's stereoness and the user constraints (mono/stereo force, rate force, format force).
That can result in a different sample rate than we expected.
If so, the down sampling setting is changed accordingly (to value 3 for forced rate).
Then, for the normal/no downsampling modes, the fr->down_sample_sblimit is set; for forced rate the ntom decoder is prepared and down_sample_limit also set.
After initialitzing audio for the first time (only for the first frame...), the new audio format is compared with the old one.
On any change, the frame data is updated and the audio reset.
Frame data change includes:

- fr->single according to resulting channel count and force mono parameter
- the audio format information itself
- (re)bytification of gapless sample addresses
- setting of synth functions (important!)
- init_layer2_stuff and init_layer3_stuff (needed on every change?)


The capability helper:

int audio_fit_capabilities(struct audio_info_struct *ai,int c,int r, struct mpg123_parameter *p)
{
	int rn;
	int f0=0;
	
	if(p->flags & MPG123_FORCE_8BIT) f0 = 2; /* skip the 16bit encodings */

	c--; /* stereo=1 ,mono=0 */

	/* force stereo is stronger */
	if(p->flags & MPG123_FORCE_MONO) c = 0;
	if(p->flags & MPG123_FORCE_STEREO) c = 1;

	if(p->force_rate) {
		rn = rate2num(p->force_rate);
		/* 16bit encodings */
		if(audio_fit_cap_helper(ai,rn,f0,2,c)) return 1;
		/* 8bit encodings */
		if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c)) return 1;

		/* try again with different stereoness */
		if(c == 1 && !(p->flags & MPG123_FORCE_STEREO))	c = 0;
		else if(c == 0 && !(p->flags & MPG123_FORCE_MONO)) c = 1;

		/* 16bit encodings */
		if(audio_fit_cap_helper(ai,rn,f0,2,c)) return 1;
		/* 8bit encodings */
		if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c)) return 1;

		error3("Unable to set up output device! Constraints: %s%s%liHz.",
		      (p->flags & MPG123_FORCE_STEREO ? "stereo, " :
		       (p->flags & MPG123_FORCE_MONO ? "mono, " : "")),
		      (p->flags & MPG123_FORCE_8BIT ? "8bit, " : ""),
		      p->force_rate);
		error1("cap: %i\n", capabilities[1][9][2]);
		if(param.verbose <= 1) print_capabilities(ai, p);
		return 0;
	}

	/* try different rates with 16bit */
	rn = rate2num(r>>0);
	if(audio_fit_cap_helper(ai,rn,f0,2,c))
		return 1;
	rn = rate2num(r>>1);
	if(audio_fit_cap_helper(ai,rn,f0,2,c))
		return 1;
	rn = rate2num(r>>2);
	if(audio_fit_cap_helper(ai,rn,f0,2,c))
		return 1;

	/* try different rates with 8bit */
	rn = rate2num(r>>0);
	if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c))
		return 1;
	rn = rate2num(r>>1);
	if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c))
		return 1;
	rn = rate2num(r>>2);
	if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c))
		return 1;

	/* try again with different stereoness */
	if(c == 1 && !(p->flags & MPG123_FORCE_STEREO))	c = 0;
	else if(c == 0 && !(p->flags & MPG123_FORCE_MONO)) c = 1;

	/* 16bit */
	rn = rate2num(r>>0);
	if(audio_fit_cap_helper(ai,rn,f0,2,c)) return 1;
	rn = rate2num(r>>1);
	if(audio_fit_cap_helper(ai,rn,f0,2,c)) return 1;
	rn = rate2num(r>>2);
	if(audio_fit_cap_helper(ai,rn,f0,2,c)) return 1;

	/* 8bit */
	rn = rate2num(r>>0);
	if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c)) return 1;
	rn = rate2num(r>>1);
	if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c)) return 1;
	rn = rate2num(r>>2);
	if(audio_fit_cap_helper(ai,rn,2,NUM_ENCODINGS,c)) return 1;

	error5("Unable to set up output device! Constraints: %s%s%i, %i or %iHz.",
	      (p->flags & MPG123_FORCE_STEREO ? "stereo, " :
	       (p->flags & MPG123_FORCE_MONO ? "mono, " : "")),
	      (p->flags & MPG123_FORCE_8BIT ? "8bit, " : ""),
	      r, r>>1, r>>2);
	if(param.verbose <= 1) print_capabilities(ai, p);
	return 0;
}


This code tries to find a 16 (if not forbidden) or 8 bit format in frame stereoness and falling back to mono/stereo.
User settings can fix the stereoness.
Either a user-defined fixed ("flexible") rate is tried without variation or it tries the supplied rate and it's half and quarter.

The really funny part for a library is that this audio format can change on the fly in one stream.
It won't do so usually, but in principle you can cat different files together and mpg123 should be able to decode them.
I admit though, that currently the parse doesn't accept mpeg version, layer or sample rate changes in one stream.
It allows stereoness changes, though.
But: The decoding function (the outsourcing of play_frame) can/will/should handle track changes -- so everything is possible.

So I need this part presented here that works out the action on format changes and the administrative part wrapped around that (read_frame_init, skip initial frames,...) to make the libmpg123 really working...
And figure out how to handle format changes in a stream... they have to be communicated to the caller; buffers shouldn't be mixed format, too.
