\documentclass[a4paper,12pt]{scrartcl}
\usepackage{pxfonts}
\usepackage{hyperref}

\begin{document}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5em}


\tableofcontents

\section{Introduction}

Over a year ago, I contributed am mpg123 binding for MPlayer to replace the old fork of mpg123 code dubbed "mp3lib". I can say "old" since we incorporated the added optimizations from that one plus added new stuff from Taihei;-)

Generally, mpg123 performs well compared to MPlayer, but there is a performance hit when using libmpg123 from MPlayer, making it slower than the built-in mp3lib. This is mostly apparent on older systems, where possibly cache misses are a source of trouble.

Specifically, the regression has been reported on K6-3+, of which I happen to have a unit available for testing. It has been confirmed for Athlons (no XP), too. Well, I happen to have a good old Duron 800 at my disposal. That should do the trick there.

\section{Test setup}

The software baseline is a current stable debian squeeze (installed from 6.0.3 media), with MPlayer and mpg123 pulled from SVN and built enforcing binaries for a K6-3 (also on the Duron), adding in 3DNowExt optimizations via custom assembly on either side.

Furthermore, the data set is, for the sake of comparability with earlier results, the MP3 album "Points of View" by "Convergence". To make sure, I talk of these files with the respective MD5 hashes:

\begin{verbatim}
04d953da593d8cfa43aee4d00572ca37 \
 /dev/shm/convergence_-_points_of_view/01 - Bleed.mp3
2999166bab6fe443f6a2c15c8eb5d938 \
 /dev/shm/convergence_-_points_of_view/02 - Strike the end.mp3
d324e12b3f20bea69c9c5e01252d0d96 \
 /dev/shm/convergence_-_points_of_view/03 - Listen.mp3
e0215065002ef2492a8d88c356609c21 \
 /dev/shm/convergence_-_points_of_view/04 - Six feet under.mp3
2b19190e15b5e5a805ccfacd789b01ab \
 /dev/shm/convergence_-_points_of_view/05 - Always the same.mp3
502c4d1e5793352fb25e6e90d6480415 \
 /dev/shm/convergence_-_points_of_view/06 - Breath.mp3
80bffd4e4bd6cc2f330b08e8156070ad \
 /dev/shm/convergence_-_points_of_view/07 - Vanished memories.mp3
de5ebd6e36eebf8c77642fa52f9610bd \
 /dev/shm/convergence_-_points_of_view/08 - Silent.mp3
c4c1167b5ca29c061d75f6104eec9283 \
 /dev/shm/convergence_-_points_of_view/09 - Nothing else.mp3
df624cee3f7b65be9b98e449e122ac63 \
 /dev/shm/convergence_-_points_of_view/10 - Train to leave.mp3
\end{verbatim}

As you may notice: I try to eliminate the hard disk at least for the test data by moving stuff to RAM. Even the K6-3+ has no issue with sparing some of its 512 MiB of RAM (the duron setup has 768 MiB).

The command lines try to do comparable things in mpg123 and MPlayer:

\begin{verbatim}
mplayer -ac mp3 -quiet -ao pcm:file=/dev/null \
   /dev/shm/convergence_-_points_of_view/*.mp3
mplayer -ac mpg123 -quiet -ao pcm:file=/dev/null \
   /dev/shm/convergence_-_points_of_view/*.mp3
mpg123 -w /dev/null /dev/shm/convergence_-_points_of_view/*.mp3
\end{verbatim}

I'm trying to combine timings with good old 'time' and measurements with 'perf'. The latter does not give much information on the K6-3+ with respect to cache misses, so I hope to do the grunt work on the Duron and hopefully the findings will transfer to the K6.

As an additional measure to avoid a penalty for libmpg123 loading, the libmpg123.a is linked in statically into MPlayer. The final solution will hopefully make the dynamic lib perform about as well (considering that stand-alone mpg123 does this successfully).

The build of MPlayer is configured via
\begin{verbatim}
./configure --extra-cflags='-march=k6-3 -mtune=k6-3 -g'
\end{verbatim}
the mpg123 build via
\begin{verbatim}
CFLAGS="-march=k6-3 -mtune=k6-3 -g -O3" ./configure --disable-shared
\end{verbatim}

That results in this set of CFLAGS: \verb:-O2: \verb:-fomit-frame-pointer: \verb:-funroll-all-loops: \verb:-finline-functions: \verb:-ffast-math:  \verb:-march=k6-3: \verb:-mtune=k6-3: \verb:-g: \verb:-O3:
Those are largely similar to what MPlayer uses, but not identical. Thinking about this... some of those might be even damaging. But: As long as standalone mpg123 has such a clear lead over MPlayer, I doubt that those make much of a difference.


\section{The situation}

How do my K6-3 binaries perform on the two systems? Well, let's record the user time to decode the test album (no statistics as long as the result is rather clear).
\begin{center}
\begin{tabular}{lrrr}
run & user time K6-III+ / s & user time Duron / s & ratio K6 / Duron \\
\hline
mpg123-debian & 51.6 & 22.4 & 2.30 \\
mpg123 & 50.4 & 22.3 & 2.26 \\
mplayer-mp3lib & 56.8 & 25.4 & 2.24 \\
mplayer-mpg123 & 67.0 & 28.7 & 2.33
\end{tabular}
\end{center}

This is using run-time choice of 3DNowExt routines. It might be interesting to compare runtimes of generic C code, the difference attesting to the respective assembly routine quality.
But let's stay focused on the case that is important in practice, and that is using 3DNowExt as the most performant choice on these CPUs.\footnote{Alas, that is limited to 16 bit output, currently.}
Let's express runtime as percent of plain mpg123 runtime:
\begin{center}
\begin{tabular}{lrr}
run & user time K6-III+ & user time Duron \\
\hline
mpg123-debian & 102.4 \% & 100.4 \% \\
mpg123 & 100.0 \% & 100.0 \% \\
mplayer-mp3lib & 112.7 \% & 113.9 \% \\
mplayer-mpg123 & 132.9 \% & 128.7 \%
\end{tabular}
\end{center}

Ivan noted a performance penalty of 6 \% on his Athlon. Well, I can offer even more: MPlayer with mpg123 binding adds 13 \% on the runtime of MPlayer with mp3lib. Cache size could explain that somewhat, as the Duron does have less of that than an Athlon, though it was not considered that much of a performance difference back then when people cared about comparing Athlons and Durons.
Anyhow, good starting point to dig at the reason for the difference, eh? I do remember trying out generic decoders on the K6-III+, there the effect was even larger. If things are unclear, I can resort to that.

\section{Glimpses with perf}

Now let's hook up with Linux Performance Events. On the K6-III+, the information was rather meager\footnote{I had to build a kernel for K6 to support performance events at all, as opposed to the debian i486 kernel.}, I hope for more stats on the Duron as a more modern / better supported CPU.
But perhaps it's just my novice usage of perf, which I didn't know before. Oh, hm. Let's see. Ah, yes... all the goodies Ivan used in his perf invocation relies on a PMU being present. That's not the case for the K6.
\begin{verbatim}
altwarentester@k6-3:~/mplayer$ perf record -f \
 -e cycles:u -e instructions:u -e l1-dcache-loads:u \
 -e l1-dcache-load-misses:u -e branch-misses \
 ./mplayer -ac mp3 -quiet -ao pcm:file=/dev/null  \
 /dev/shm/convergence_-_points_of_view/*.mp3

  Error: perfcounter syscall returned with -1 (No such device)

  Fatal: No CONFIG_PERF_EVENTS=y kernel support configured?
\end{verbatim}
It seems the only diagnostic I get is cycles, and that's not very special. On the Duron:
\begin{verbatim}
altwarentester@duron:~/mplayer$ perf record -f \
 -e cycles:u -e instructions:u -e l1-dcache-loads:u \
 -e l1-dcache-load-misses:u -e branch-misses \
 ./mplayer -ac mp3 -quiet -ao pcm:file=/dev/null  \
 /dev/shm/convergence_-_points_of_view/*.mp3
  Error: failed to mmap with 1 (Operation not permitted)
\end{verbatim}
Well. That's nearly success. I have to increase the allowed locked memory count from the default 64 K.

Now let's see what we've got. Hm, recording works, but I don't get how to report all that wonderful information.
Plain \verb:perf report: doesn't tell more than usual. I can do that call graph thing, but also here, there is still some strangeness going on with the mpg123 symbols. I'll figure that out.

In the meantime, there is \verb:perf stat:, which gives a nice overall picture:

\begin{verbatim}
altwarentester@duron:~/mplayer$ perf stat ./mplayer -ac mpg123 \
 -quiet -ao pcm:file=/dev/null    /dev/shm/convergence_-_points_of_view/*.mp3

   29435.786923  task-clock-msecs         #      0.994 CPUs 
            216  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6780  page-faults              #      0.000 M/sec
    23502185554  cycles                   #    798.422 M/sec
    22870306002  instructions             #      0.973 IPC  
     8562390418  cache-references         #    290.884 M/sec
       17327364  cache-misses             #      0.589 M/sec

   29.605841362  seconds time elapsed
\end{verbatim}

\begin{verbatim}
altwarentester@duron:~/mplayer$ perf stat ./mplayer -ac mp3 \
 -quiet -ao pcm:file=/dev/null    /dev/shm/convergence_-_points_of_view/*.mp3

   26210.959074  task-clock-msecs         #      0.993 CPUs 
            207  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6290  page-faults              #      0.000 M/sec
    20923114721  cycles                   #    798.258 M/sec
    20818859901  instructions             #      0.995 IPC  
     7867755901  cache-references         #    300.170 M/sec
       10962558  cache-misses             #      0.418 M/sec

   26.387378954  seconds time elapsed
\end{verbatim}

\begin{verbatim}
altwarentester@duron:~$ perf stat mpg123/src/mpg123 -w /dev/null \
 /dev/shm/convergence_-_points_of_view/*.mp3

   23163.487659  task-clock-msecs         #      0.996 CPUs 
            140  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            337  page-faults              #      0.000 M/sec
    18501736597  cycles                   #    798.746 M/sec
    20408582208  instructions             #      1.103 IPC  
     7871105536  cache-references         #    339.807 M/sec
       11304577  cache-misses             #      0.488 M/sec

   23.246529422  seconds time elapsed
\end{verbatim}

The K6 is not that generous with details (not counted from cycles on).
Regarding cache misses, that's 17 million for mplayer-mpg123, 11 million for mplayer-mp3 and a similar 11 million for plain mpg123. OK, it is sub-optimal. I know that. Now how to dig deeper? I do wonder if switching to generic C code would help since this reduces the amount of functions involved.

\section{The situation with generic C code}

Let's try that: Force MPlayer not to activate special optimizations, tell mpg123 to stick to generic decoding. Hm. I see that mp3lib generic code is actually the i386 code. Well, then, two can play that game.

\begin{verbatim}
altwarentester@duron:~$ perf stat mpg123/src/mpg123 --cpu i386 \
 -w /dev/null /dev/shm/convergence_-_points_of_view/*.mp3

   44296.192117  task-clock-msecs         #      0.996 CPUs 
            263  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            335  page-faults              #      0.000 M/sec
    35386827671  cycles                   #    798.868 M/sec
    34153833893  instructions             #      0.965 IPC  
    10346222151  cache-references         #    233.569 M/sec
       13440804  cache-misses             #      0.303 M/sec

   44.465953954  seconds time elapsed
\end{verbatim}

\begin{verbatim}
altwarentester@duron:~/mplayer-generic$ perf stat ./mplayer -ac mp3 \
  -quiet -ao pcm:file=/dev/null    /dev/shm/convergence_-_points_of_view/*.mp3

   32032.688338  task-clock-msecs         #      0.994 CPUs 
            233  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6284  page-faults              #      0.000 M/sec
    25575954000  cycles                   #    798.433 M/sec
    28423479288  instructions             #      1.111 IPC  
     9061572976  cache-references         #    282.885 M/sec
       13821093  cache-misses             #      0.431 M/sec

   32.228199936  seconds time elapsed
\end{verbatim}

\begin{verbatim}
altwarentester@duron:~/mplayer-generic$ perf stat ./mplayer -ac mpg123 \
  -quiet -ao pcm:file=/dev/null    /dev/shm/convergence_-_points_of_view/*.mp3

   49121.685292  task-clock-msecs         #      0.995 CPUs 
            309  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6781  page-faults              #      0.000 M/sec
    39219721233  cycles                   #    798.420 M/sec
    35350587000  instructions             #      0.901 IPC  
    10824302596  cache-references         #    220.357 M/sec
       21094060  cache-misses             #      0.429 M/sec

   49.370325203  seconds time elapsed
\end{verbatim}

Wait a moment... This looks a lot like mpg123's C code being mashed into an inferior binary form.
It's still slower from MPlayer than from stand-alone mpg123, but the comparison to mp3lib is harsh.
But then, wait a bit more: Is MPlayer really playing fair? Did I hack mp3lib correctly?
Those 32 seconds aren't that much more than 26 seconds. Let's record.

Hm, well... it looks like generic code, alright. Building mpg123 with \verb:-O4: and the rest of the MPlayer CFLAGS doesn't change too much: runtime stays around 44 seconds for standalone mpg123.
But the comparison is still somewhat interesting: Cache is not the point here.
\begin{verbatim}
altwarentester@duron:~/mpg123-mpopt$ perf stat src/mpg123 --cpu i386 \
 -w /dev/null    /dev/shm/convergence_-_points_of_view/*.mp3

   44294.299679  task-clock-msecs         #      0.996 CPUs 
            272  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            325  page-faults              #      0.000 M/sec
    35383207571  cycles                   #    798.821 M/sec
    34414257475  instructions             #      0.973 IPC  
    10373238416  cache-references         #    234.189 M/sec
       17922320  cache-misses             #      0.405 M/sec

   44.451762052  seconds time elapsed
\end{verbatim}
Well, that fits with the earlier comparison: Differences in cache hit or miss are not really significant, the mpg123 C code plainly sucks!

So, I got two issues at hand:
\begin{itemize}
	\item With 3DNowExt code, there is a definite penalty that MPlayer gets compared to stand-alone mpg123. This might have to do with CPU cache performance.
	\item The non-assembly mpg123 code doesn't work out well compared to MPlayer's C code. I had a peek and it really looks like the synth function just needs (much) more time.
\end{itemize}
Great. Which one will I fix? I must admit that I am tempted to find out what works differently with the mpg123 C code in its two incarnations. Well, for starters, it could be the change I had to make to give the code thread-safety. That meant movement of quite some data structures from static variables to the handle on the heap.

Let'c check mpg123-0.68, which predates the move to the thread-safe library, with the MPlayer CFLAGS:
\begin{verbatim}
altwarentester@duron:~/mpg123-0.68$ perf stat src/mpg123 --cpu i386 \
 -w /dev/null    /dev/shm/convergence_-_points_of_view/*.mp3

   43475.950745  task-clock-msecs         #      0.996 CPUs 
            264  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            317  page-faults              #      0.000 M/sec
    34730969332  cycles                   #    798.855 M/sec
    34317362404  instructions             #      0.988 IPC  
    10323913086  cache-references         #    237.463 M/sec
       12847122  cache-misses             #      0.295 M/sec

   43.628917385  seconds time elapsed
\end{verbatim}
Does not look like that much of an extra hit. Well, about 2 \% difference to the current version there. So, it's not nothing.
But in that range I lean to argue that there has to be {\em some} cost involved in making the code thread-safe, with all that data in the handle and al.
Of course, my approach to libmpg123 should have room for cleanup and optimization per se, but we are not talking about 2 \% here, compared to mp3lib. This is more serious than the simple transition to libmpg123.

It is difficult to test earlier versions of mpg123 since they happen not to like my test data. One should not forget that I added bug fixes over time! Well, I suspect my approach to CPU runtime optimization choice.
Found a set of old MP3s to work on (``Dune'', by ... eh... ``Dune'')... and the difference is appaling:

\begin{verbatim}
altwarentester@duron:~/mpg123-0.59r$ perf stat ./mpg123 -t \
 /home/altwarentester/dune/*.mp3

   23312.117777  task-clock-msecs         #      0.996 CPUs 
            152  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
          14344  page-faults              #      0.001 M/sec
    18623038218  cycles                   #    798.857 M/sec
    24254735169  instructions             #      1.302 IPC  
     8597454473  cache-references         #    368.798 M/sec
        4262514  cache-misses             #      0.183 M/sec

   23.394514625  seconds time elapsed
\end{verbatim}
\begin{verbatim}
altwarentester@duron:~/mpg123-0.68$ perf stat ./mpg123 -t \
 /home/altwarentester/dune/*.mp3

   32211.610636  task-clock-msecs         #      0.996 CPUs 
            199  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            296  page-faults              #      0.000 M/sec
    25731964846  cycles                   #    798.841 M/sec
    30810795898  instructions             #      1.197 IPC  
    10904946603  cache-references         #    338.541 M/sec
        7285056  cache-misses             #      0.226 M/sec

   32.326412050  seconds time elapsed
\end{verbatim}

Frick. That is a huge hit. Hah! I even forgot to specify \verb:--cpu i386:. With that, I'm at around \textbf{70 seconds}.
Something smells fishy.

\section{What happened to mpg123 on the way to 0.68?}

Comparing 0.59r and 0.68 furher... decoding one of the dune tracks, where the old version needs 2.5 seconds and the new one over 6 seconds.
Reports:

\begin{verbatim} 
altwarentester@duron:~/mpg123-0.59r$ perf report
# Samples: 15180
#
# Overhead      Command                  Shared Object  Symbol
# ........  ...........  .............................  ......
#
    45.76%       mpg123  ./mpg123                       [.] III_dequantize_sample
    20.47%       mpg123  ./mpg123                       [.] dct64
    15.01%       mpg123  ./mpg123                       [.] dct36
     9.65%       mpg123  ./mpg123                       [.] do_layer3
     3.41%       mpg123  ./mpg123                       [.] synth_1to1
     1.98%       mpg123  ./mpg123                       [.] dct12
     1.03%       mpg123  /lib/i686/cmov/libc-2.11.2.so  [.] memcpy
\end{verbatim}


\begin{verbatim}
altwarentester@duron:~/mpg123-0.68$ perf report
# Samples: 44859
#
# Overhead      Command                  Shared Object  Symbol
# ........  ...........  .............................  ......
#
    65.42%       mpg123  ./src/mpg123                   [.] synth_1to1_i386
    15.60%       mpg123  ./src/mpg123                   [.] III_dequantize_sample
     7.63%       mpg123  ./src/mpg123                   [.] dct64_i386
     4.91%       mpg123  ./src/mpg123                   [.] dct36
     3.07%       mpg123  ./src/mpg123                   [.] do_layer3
     0.70%       mpg123  ./src/mpg123                   [.] dct12
     0.34%       mpg123  ./src/mpg123                   [.] III_get_scale_factors_1
     0.33%       mpg123  [kernel]                       [k] __copy_to_user_ll
     0.12%       mpg123  [kernel]                       [k] generic_file_aio_read
\end{verbatim}

I seriously borked up the synth function for this CPU. But remember: This is code that is not run in the initially considered case, only when I enforce avoidance of the optimized decoders.
But it could be symptomatic.

\paragraph{Oh, dear.} I listened to some output from 0.59r. It's crap, distorted something.
So, perhaps that just doesn't count. weren't it for the finding that the synth function is more heavy also compared to mp3lib.
Taking a look at mpg123 0.60. Perhaps that's more sane.
No, it isn't. The fun fact is that it works fine on my 64 bit laptop with generic decoder... hm... would generic work?
Yes, the generic decoder works also on the Duron. But it's slow, just about as current mpg123.

Fun question: Does MPLayer with the i386 mp3lib decode correctly, like current mpg123? Yes it does.
Result looks good. Computing time looks better.

Last resort of mpg123 without multi-cpu code: 0.65. Will that produce proper output? Will it be faster? It produces crap. Faster. Only mpg123-0.66 finally produces proper output with i386 decoder. But is that a generic property?
Shouldn't I have noticed such breakage before? I don't see it mentioned in NEWS.

There it is:
\begin{verbatim}
------------------------------------------------------------------------
r577 | thor | 2007-02-22 03:04:23 +0100 (Do, 22. Feb 2007) | 4 Zeilen

fixing i386 code with gcc-4.1 by using the old WRITE_SAMPLE again - the
new one has distorted sound and gcc complains about strict aliasing ...
the old WRITE_SAMPLE even seems to be faster with gcc-3.4!
Of course I didn't (yet) test on my real i386DX40 if there's an advantage.
Started mocking with cpuflags to get proper MMX and SSE detection.

------------------------------------------------------------------------
\end{verbatim}
Well, there it may be. Let's switch around \verb:WRITE_SAMPLE:. And we got a change from
\begin{verbatim}
    2566.163526  task-clock-msecs         #      0.994 CPUs 
             21  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            300  page-faults              #      0.000 M/sec
     2047880985  cycles                   #    798.032 M/sec
     2041781623  instructions             #      0.997 IPC  
      798943574  cache-references         #    311.338 M/sec
        4049486  cache-misses             #      1.578 M/sec

    2.581971582  seconds time elapsed
\end{verbatim}
to
\begin{verbatim}
    6272.432955  task-clock-msecs         #      0.989 CPUs 
             51  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            300  page-faults              #      0.000 M/sec
     5006116015  cycles                   #    798.114 M/sec
     4398072978  instructions             #      0.879 IPC  
     1320889896  cache-references         #    210.587 M/sec
        4730705  cache-misses             #      0.754 M/sec

    6.343654290  seconds time elapsed
\end{verbatim}
Very well. Seems like I have to learn from MPlayer about fixing up the new \verb:WRITE_SAMPLE:.
And yes, there is something in revision 7300; something about gcc 3.x being too clever for the double - int conversion trick. Applying the fix from MPlayer to mpg123 0.65 yields
\begin{verbatim}
    5213.636059  task-clock-msecs         #      0.985 CPUs 
             46  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            301  page-faults              #      0.000 M/sec
     4161133383  cycles                   #    798.125 M/sec
     4203986268  instructions             #      1.010 IPC  
     1302169739  cache-references         #    249.762 M/sec
        4555437  cache-misses             #      0.874 M/sec

    5.293784289  seconds time elapsed
\end{verbatim}
(and good-sounding output, of course).

Going back to the original test album, writing to /dev/null (the stuff before wrote to a real file to check the output):
\begin{verbatim}
   35322.795994  task-clock-msecs         #      0.996 CPUs 
            215  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            315  page-faults              #      0.000 M/sec
    28215905365  cycles                   #    798.802 M/sec
    32624122756  instructions             #      1.156 IPC  
    10324164674  cache-references         #    292.281 M/sec
       12229060  cache-misses             #      0.346 M/sec

   35.457957266  seconds time elapsed
\end{verbatim}
That's not 70 seconds. \verb:WRITE_SAMPLE: is a sore spot, but that it is that influential on the Duron is a surprise. I have to check on a more modern system, with a 32 bit install.
But where came the 70 seconds from anyway? The current mpg123 had only about 44 seconds. This CPU is sensitive. And don't forget: I observed the old \verb:WRITE_SAMPLE: even being faster back then!

Anyhow, 35 seconds is still above the 32 seconds mp3lib achieves. There is more to the generic/i386 C code. Stay tuned.

Found MPlayer rev. 28866. Reducing the size of bandInfoStruct bring that:
\begin{verbatim}
   35303.691456  task-clock-msecs         #      0.996 CPUs 
            215  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            314  page-faults              #      0.000 M/sec
    28199408110  cycles                   #    798.767 M/sec
    32624433817  instructions             #      1.157 IPC  
    10330702614  cache-references         #    292.624 M/sec
       14060449  cache-misses             #      0.398 M/sec

   35.430962884  seconds time elapsed
\end{verbatim}
In short: nothing. The preceeding rev. 28865 has some \verb:const: stuff. That might play a role. Then there is Zuxy's rev. 23485 that changed some static vars to automatic. Generally, he worked on SSE stuff, that's not of interest right now.
There is the \verb:fast_memcpy: business. I should check that. Rev. 22158 does buffer alignment.
Revision 18946 fixes something in the 3DNow DCT64 ... and makes we wonder what exactly is the relation of mpg123's and MPlayers plain 3DNow code. That is another matter to investigate.

For now, it seems that it is fruitful enough to pursue merging of apparent improvements in the generic/overall C code of mp3lib that we indeed still miss in mpg123.

Hacking the ``new'' \verb:WRITE_SAMPLE: into current mpg123 does yield a tiny improvement over the hacked 0.65, even.
\begin{verbatim}
altwarentester@duron:~/mpg123$ perf stat ./src/mpg123 -w /dev/null \
 --cpu i386  /dev/shm/convergence_-_points_of_view/*.mp3

   35030.997934  task-clock-msecs         #      0.996 CPUs
            225  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            333  page-faults              #      0.000 M/sec
    27983581759  cycles                   #    798.823 M/sec
    33233941274  instructions             #      1.188 IPC
    10325844134  cache-references         #    294.763 M/sec
       11774779  cache-misses             #      0.336 M/sec
   
   35.176724921  seconds time elapsed
\end{verbatim}
\begin{verbatim}
altwarentester@duron:~/mpg123-0.65$ perf stat ./src/mpg123 -w /dev/null \
 /dev/shm/convergence_-_points_of_view/*.mp3

   35215.369977  task-clock-msecs         #      0.995 CPUs
            226  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            314  page-faults              #      0.000 M/sec
    28126526481  cycles                   #    798.700 M/sec
    32624128394  instructions             #      1.160 IPC
    10335841084  cache-references         #    293.504 M/sec
       12821386  cache-misses             #      0.364 M/sec
   
   35.387834336  seconds time elapsed
\end{verbatim}
Too bad that this doesn't fit the current framework of separated clipping and conversion too well. Seems like, at least for some CPUs (I really should wire up the i486, or even the i386...), this separation hurts.
But then: We are talking about the i386 C code, which is not used by default from old Pentiums onwards. This is rather academic. The performance of the plain C code doesn't matter at all in practice, when there's nowadays a variant of Taihei's SSE code in use.

In MPlayer, this change improves the situation, but it is still 39 seconds against 32 seconds:
\begin{verbatim}
perf stat ./mplayer -ac mp3 -ao pcm:file=/dev/null -quiet \
 /dev/shm/convergence_-_points_of_view/*.mp3

   32049.354400  task-clock-msecs         #      0.994 CPUs 
            249  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6293  page-faults              #      0.000 M/sec
    25589163911  cycles                   #    798.430 M/sec
    28424067520  instructions             #      1.111 IPC  
     9060506927  cache-references         #    282.705 M/sec
       12323035  cache-misses             #      0.385 M/sec

   32.251952962  seconds time elapsed
\end{verbatim}
\begin{verbatim}
perf stat ./mplayer -ac mpg123 -ao pcm:file=/dev/null -quiet \
 /dev/shm/convergence_-_points_of_view/*.mp3

   39542.041678  task-clock-msecs         #      0.994 CPUs 
            298  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6790  page-faults              #      0.000 M/sec
    31575386518  cycles                   #    798.527 M/sec
    34341985738  instructions             #      1.088 IPC  
    10817342380  cache-references         #    273.566 M/sec
       17943896  cache-misses             #      0.454 M/sec

   39.787800467  seconds time elapsed
\end{verbatim}

\section{Why does GCC hate my code?}

But how does the picture of CPU usage per function look now?
With mp3lib:
\begin{verbatim}
    36.40%      mplayer  ./mplayer                            [.] synth_1to1
    28.16%      mplayer  ./mplayer                            [.] III_dequantize_sample
    10.59%      mplayer  ./mplayer                            [.] dct64_1
     9.05%      mplayer  ./mplayer                            [.] dct36
     4.23%      mplayer  ./mplayer                            [.] T.293
     3.92%      mplayer  /lib/i686/cmov/libc-2.11.2.so        [.] memcpy
\end{verbatim}
With libmpg123:
\begin{verbatim}
    40.43%      mplayer  ./mplayer                            [.] INT123_synth_1to1_i386
    22.31%      mplayer  ./mplayer                            [.] III_dequantize_sample
     7.68%      mplayer  ./mplayer                            [.] INT123_dct36
     6.73%      mplayer  ./mplayer                            [.] INT123_dct64_i386
     6.07%      mplayer  /lib/i686/cmov/libc-2.11.2.so        [.] memcpy
     3.51%      mplayer  ./mplayer                            [.] INT123_synth_ntom
     3.35%      mplayer  ./mplayer                            [.] INT123_do_layer3
     1.25%      mplayer  ./mplayer                            [.] feed_read
\end{verbatim}
That's still quite some overhang for the synth function itself.
And even if it's totally irrelevant in practice... I want to see how I messed up the synth function for Durons.

\paragraph{A quick look on the Core2Duo in 32 bit chroot:}
An mpg123 binary built with '-march=pentium3' and mpg123 default optimization shows perhaps {\em some} difference regarding the \verb:WRITE_SAMPLE: change. using i386 decoder.
I might be convinced to give it 2 \% advantage.
It's harder to tell a difference when using the generic decoder, but there might be one. When building for \verb:-march=pentium:, both differences are around 1 to 1.5 \%.
One would need some statistics for more definite answer, but the main point is: The effect, if any, is much less pronounced on the Core2Duo machine. Might be a reason for me not spotting anything wrong. The message behind this, of course, is that tuning things for the Duron should not hurt performance on newer machines (which use SSE optimization anyway, d'oh).

\paragraph{A root cause}
of the slowness seems to be some inefficient translation of \verb:WRITE_SAMPLE: resulting in floating point stack messiness.
Seems like the summand for the \verb:fadd: is kept on the fp stack in mp3lib, but is grabbed from main stack repeatedly for mpg123. One indicator is the appearance of the \verb:fxch: instruction in mpg123's \verb:synth_1to1: function.
It is totally absent in mp3lib's version.

Now the question is how I can rearrange to code to avoid this. I am working on the 0.65 source to stay closer to mp3lib.

\paragraph{A cause to the cause?}
Yes, there might be a simple explanation: The GCC optimizer is pushed along different ways because the mpg123 code is built to separate object files, with public functions, while mp3lib pushes everything into a single object, with stuff like \verb:synth_1to1: being all-static.
That eases optimzation of (floating point) stack usage.

An interesting side note is that for the mpg123 code, the floating point stack messup seems to be pushed by enabling optimization at all.

But anyway, repackaging the stuff to have the direct calls to the synth functions together with the (then static) functions might do the trick.
For modern mpg123 this would mean packaging all synth functions and \verb:layer[123].c: files together with \verb:optimise.c:, perhaps \verb:frame.c:, into one compilation unit.
An indicator could be this: If there are public symbols that are not part of the API in a static libmpg123, those symbols should have been static and {\em not} public.

Of course, performance is only one possible reason to make these functions static:
It is bad library design to have those symbols floating around and possibly colliding when someone uses the static library.

I tried this on the Core2Duo and, if anything, this makes things perhaps slightly worse. On the Duron the tendency to worsen the performance is also indicated. At least the more static build is about 0.5 K smaller. The effect of adapting Dan's patch for const huffman tables is bigger (both in performance and binary size).
But still, this is not really big. I need to get to the core of the bad WRITE\_SAMPLE translation. How does the compiler get the hint from MPlayer code? And... how about building with the Intel or open64 compilers for a change?
Well, one bummer is that I have those installed for 64 bits, not 32.

On the Duron, the effect of the const tables is also quite small.

\section{Revisit after some time...}

Just make sure I still know what I am talking about, mpg123-0.65-like-mplayer r3005, my old MPlayer checkout, both with i386 C code. Perf says for MPlayer:
\begin{verbatim}
   32331.247743  task-clock-msecs         #      0.994 CPUs 
            371  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
           6301  page-faults              #      0.000 M/sec
    25814521225  cycles                   #    798.439 M/sec
    28424759003  instructions             #      1.101 IPC  
     9068719643  cache-references         #    280.494 M/sec
       13063911  cache-misses             #      0.404 M/sec

   32.523356972  seconds time elapsed

# Samples: 270005
#
# Overhead      Command                        Shared Object  Symbol
# ........  ...........  ...................................  ......
#
    35.82%      mplayer  ./mplayer                            [.] synth_1to1
    28.14%      mplayer  ./mplayer                            [.] III_dequantize_sample
    10.57%      mplayer  ./mplayer                            [.] dct64_1
     9.18%      mplayer  ./mplayer                            [.] dct36
     4.19%      mplayer  ./mplayer                            [.] T.293
     4.07%      mplayer  /lib/i686/cmov/libc-2.11.2.so        [.] memcpy
     0.56%      mplayer  ./mplayer                            [.] fast_memcpy
\end{verbatim}
And for mpg123:
\begin{verbatim}
   34845.338614  task-clock-msecs         #      0.996 CPUs
            377  context-switches         #      0.000 M/sec
              0  CPU-migrations           #      0.000 M/sec
            245  page-faults              #      0.000 M/sec
    27835529165  cycles                   #    798.831 M/sec
    32659069064  instructions             #      1.173 IPC
    10169107285  cache-references         #    291.836 M/sec
        8112060  cache-misses             #      0.233 M/sec
   
   34.982723275  seconds time elapsed

# Samples: 292093
#
# Overhead      Command                        Shared Object  Symbol
# ........  ...........  ...................................  ......
#
    51.58%       mpg123  ./src/mpg123                         [.] synth_1to1
    24.78%       mpg123  ./src/mpg123                         [.] III_dequantize_sample
     8.20%       mpg123  ./src/mpg123                         [.] dct64
     7.84%       mpg123  ./src/mpg123                         [.] dct36
     3.73%       mpg123  ./src/mpg123                         [.] do_layer3
     0.52%       mpg123  [kernel]                             [k] __copy_to_user_ll
     0.31%       mpg123  ./src/mpg123                         [.] dct12
     0.25%       mpg123  ./src/mpg123                         [.] III_get_scale_factors_1
     0.17%       mpg123  /lib/i686/cmov/libc-2.11.2.so        [.] __mempcpy
\end{verbatim}
It is still apparent that synth of mpg123 needs more time. 51.6\% of 35 seconds, that is, 18 seconds.
For MPlayer, that's 35.8\% of 32.5 secods. 11.6 seconds.
Let's summarize that.
\begin{center}
\begin{tabular}{lrr}
function & time MPlayer / s & time mpg123 / s
\\\hline
synth\_1to1 & 11.64 & 18.04 \\
III\_dequantize\_sample & 9.15 & 8.67 \\
dct64 & 3.44 & 2.87 \\
dct36 & 2.99 & 2.74 \\
T.293 / do\_layer3 & 1.36 & 1.30
\end{tabular}
\end{center}

That does look interesting. If only the synth function were faster, mpg123 would easily beat mp3lib. All other main functions are a tad quicker, even, than the mp3lib counterparts!
The \verb:perf annotate: ist not too helpful in placing the blame on certain code portions, but I know already what the main difference is. Or do I?
The annotations show huge runtime hit for the faddp instruction in mpg123, where it doesn't really count in MPlayer, at the sample places.

The output of \verb:perf annotate: is confusing. The association of code and assembly seems rather whacky. But first, what is {\em that}?
\begin{verbatim}
     :          for (j=16;j;j--,b0+=0x10,window+=0x20,samples+=step)
0.14 :       806ca36:       83 c3 40                add    $0x40,%ebx
0.64 :       806ca39:       83 c2 40                add    $0x40,%edx
0.01 :       806ca3c:       83 e9 80                sub    $0xffffff80,%ecx
0.22 :       806ca3f:       83 c6 04                add    $0x4,%esi
1.11 :       806ca42:       81 fb 00 04 00 00       cmp    $0x400,%ebx
0.00 :       806ca48:       0f 84 22 01 00 00       je     806cb70 <synth_1t
0.10 :       806ca4e:       dd d8                   fstp   %st(0)
0.83 :       806ca50:       dd d8                   fstp   %st(0)
0.12 :       806ca52:       dd d8                   fstp   %st(0)
0.02 :       806ca54:       dd d8                   fstp   %st(0)
0.47 :       806ca56:       dd d8                   fstp   %st(0)
0.09 :       806ca58:       dd d8                   fstp   %st(0)
\end{verbatim}
Such floating point stack messing around is not to be found, in MPlayer. Then, the detail:
\begin{verbatim}
     :            sum += window[0x4] * b0[0x4];
1.18 :       82478f2:       d9 42 20                flds   0x20(%edx)
0.60 :       82478f5:       d8 49 20                fmuls  0x20(%ecx)
0.11 :       82478f8:       de c1                   faddp  %st,%st(1)
     :            sum -= window[0x5] * b0[0x5];
0.71 :       82478fa:       d9 42 28                flds   0x28(%edx)
0.46 :       82478fd:       d8 49 28                fmuls  0x28(%ecx)
0.17 :       8247900:       de c1                   faddp  %st,%st(1)
\end{verbatim}
And a similar portion from mpg123:
\begin{verbatim}
         :            sum += window[0x4] * b0[0x4];
    0.36 :       806caca:       d9 44 24 34             flds   0x34(%esp)
    0.00 :       806cace:       d8 49 20                fmuls  0x20(%ecx)
    1.90 :       806cad1:       de c7                   faddp  %st,%st(7)
         :            sum -= window[0x5] * b0[0x5];
    0.35 :       806cad3:       d9 44 24 2c             flds   0x2c(%esp)
    0.00 :       806cad7:       d8 49 28                fmuls  0x28(%ecx)
    2.09 :       806cada:       de c7                   faddp  %st,%st(7)
\end{verbatim}
The exact attribution to one instruction might be tough here, but it is apparent that very similar pieces of code perform consistently different. The location on the floating point stack is different.
And, hm, why are array offsets different?
This pattern is carried through: The MPlayer code has matching offsets on the load and multiplication operations, especially matching the array offsets in the C code.
In mpg123, that is different.


\paragraph{Comparing the code for the two synth functions,}
I see only one difference at all: The possible call of the equalizing function.
Hm, it might be worth a try to remove that bit of code. It introduces a branch... and inserts code for a possible function call.
But no, that doesn't make a difference. I'm relieved.

Now, that leaves the strange decisions of the compiler on the table. It does {\em weird} stuff with the floating point sums. Generally, the floating point code is messy. What's the magic compiler switch to change that?

I added some disassembly and the corresponding source to SVN, the public may have a peek at \url{http://mpg123.orgis.org/cgi-bin/scm/mpg123/notes/beating_mp3lib_in_mplayer_material/}.

Separating out the synth function in the MPlayer code into its own object file (not static, obviously) yields binary code very similar to what gcc produces for mpg123.

\paragraph{A proposal for different clipping}
from Ivan didn't do much good on the Duron, actually worsened it a bit. The idea was to save one if branch by  addition and bitmask comparison, but this is not guaranteed to be faster...
Anyhow, this is tangential to the question why the MPlayer build works better.

\paragraph{Back to the assembly line},
my gaze wanders towards the differences outlined above again, and I realize that the array index strangeness might have to do with the fact that there is \%esp involved in mpg123. 
The function stack versus a pointer in a separate register.
Oh, also, I see a trigger for the bad code: Removing the call to DCT64 improves things, not entirely surprisingly.
This is a piece of diff between the separated-out synth function without and with call to non-static dct64:
\begin{verbatim}
119,121c170,172
<   93: d9 41 20                flds   0x20(%ecx)
<   96: d8 4a 20                fmuls  0x20(%edx)
<   99: de c2                   faddp  %st,%st(2)
---
>  109: d9 44 24 28             flds   0x28(%esp)
>  10d: d8 4a 20                fmuls  0x20(%edx)
>  110: de c7                   faddp  %st,%st(7)
123,125c174,176
<   9b: d9 41 28                flds   0x28(%ecx)
<   9e: d8 4a 28                fmuls  0x28(%edx)
<   a1: de c2                   faddp  %st,%st(2)
---
>  112: d9 44 24 20             flds   0x20(%esp)
>  116: d8 4a 28                fmuls  0x28(%edx)
>  119: de c7                   faddp  %st,%st(7)
\end{verbatim}
Now, as I said, a function call messing with stack/register handling is not entirely spurprising.
But, still, I should wrap my head around what exactly happens here.
Especially, since including static dct64 didn't seem to help mpg123. But what does it do here? Let's try.

Gah! Static! I forgot that there are static variables in the synth function (there aren't anymore for current mpg123). I simply defined the static keyword to nothing for the separated object, only thinking about the static function, not static variables.
Does the situation change when I just remove the static keyword from the function?
\begin{verbatim}
156,158c223,225
<   b2: d9 42 20                flds   0x20(%edx)
<   b5: d8 49 20                fmuls  0x20(%ecx)
<   b8: de c1                   faddp  %st,%st(1)
---
>  144: d9 44 24 34             flds   0x34(%esp)
>  148: d8 49 20                fmuls  0x20(%ecx)
>  14b: de c7                   faddp  %st,%st(7)
160,162c227,229
<   ba: d9 42 28                flds   0x28(%edx)
<   bd: d8 49 28                fmuls  0x28(%ecx)
<   c0: de c1                   faddp  %st,%st(1)
---
>  14d: d9 44 24 2c             flds   0x2c(%esp)
>  151: d8 49 28                fmuls  0x28(%ecx)
>  154: de c7                   faddp  %st,%st(7)
\end{verbatim}
OK, that's still the same, basically. Only the stack location changes.
Now, how does the stuff land on the stack anyways?

\paragraph{An indication of victory}
is that, after simply disabling the call to dct64 (and, thusly, producing rubbish) both in mp3lib and mpg123, the mpg123 binary beats MPlayer with 25 agains 28 seconds decoding time.
This function call messes up the code optimization for mpg123 and somehow does not for mp3lib.

\end{document}

