libmpg123 with (sample-accurate) seeking

These notes start with the basically working mpg123lib branch and document the process of adding proper seeking to that one.

The basic unit of MPEG audio is a frame, consisting of a certain number of mono/stereo samples (a stereo sample being what sometimes is referred to as a frame in digital audio).
For the sake of seeking and bearing any practical purpose, I consider mpeg streams that have a fixed number of samples per frame.
The seek to a specific sample position s thus means first seek to the frame n that contains s:

n = s/spf(fr)

Then just ignore the i leading samples from that frame:

i = s-n*spf(fr)

An optimization is of course to detect whether we actually have to go to a different than the current frame...
But focus on the general thing here.
For layer 3 the samples for one frame also depend on the frame before. I will just run the leading frame through the parser/decoder to have everything straight - adding to the ignore sample count:

n_2 = n-1
i_2 = s-(n-1)*spf(fr)

That simple computation works without thinking about gapless decoding, where a certain number of samples at the beginning (and end) is to be discarded anyway.
The sample addresses of interest are the addresses after the padding/delay samples have been ignored - gapless audio shall be transparent (for layer3...).
So from padding/delay info there are the overall samples to ignore from the beginning (g_i) and to the end (g_e).
We have to distinguish the "real file" sample position p_r and the output sample position p_o...

p_o = p_r - g_i


seek(p_o)

That means:

1. Go to one frame before (for layer 3 at least) the one containing the "real" sample p_r = p_o + g_i; which is n_2 = p_r / spf(fr) - 1
2. Figure out how many samples to ignore from beginning of that frame:
	Since we calculated the gapless ignores already into the difference of internal and external sample position, one does not have to recall both now; just the offset to p_r counts:
	i_r = p_r - n_2*spf(fr)
3. Start decoding, ignoring samples via the gapless code.
	Also mpg123_decode_frame should not return simply after decoding one frame, but after decoding a frame with some unignored samples.


And when there is no gapless option built in?

Then we just ditch the sample-accurate seeking and go back to fast frame-accurate seeking.
But I should still add the twist of seeking a frame further back and decode/ignore it.
At least for layer3...


About Positions

Currently, there are some values stored for position info in the frame structure:

	off_t num; /* the nth frame in some stream... */

	off_t position; /* position in raw decoder bytestream */
	off_t begin_s;  /* in samples */
	off_t end_s;
	off_t begin; /* first byte to play == number to skip */
	off_t end; /* last byte to play */
	off_t ignore; /* forcedly ignore stuff in between */


fr.num is the last decoded frame offset ... at least just after do_layer has been called.
If fr.to_decode == TRUE, then fr.num-1 is the last decoded offset.

Ahywho... the detailed output position currently is advanced in the gapless buffercheck function.:

fr.position += fr.buffer.fill

So at a certain moment with a filled buffer, there are bytes fr.position-fr.buffer.fill till fr.position-1 available.
Hm. But do I really need that byte offset stuff?
For seeking I'll rather use segmented memory access: Go to a frame, then do an offset in there.
But does that remove the need for byte position tracking for gapless playback?
The tricky part here is the removal of padding samples at the _end_.
But actually, with the requirement of a consistent stream, the end of audio is defined via a frame number and offset in that last frame until which to play.
Tracking of frame numver should be enough.

fr.firstframe = fr.begin_s/spf(fr)
fr.firstoff   = fr.begin_s - fr.firstframe*spf(fr)
fr.lastframe  = fr.end_s/spf(fr)
fr.lastoff    = fr.end_s - fr.lastframe*spf(fr)

So just parse until we reach firstframe, ignore fr.firstoff samples (we know current audio format now!).
Then return the data.
if we reached the last frame, ignore anything _after_ fr.lastoff.
That just means adjusting the read pointer and fill of the buffer.

Now for seeking, this gets input stream hurled to somewhere before desired positon and sets a different fr.firstframe and fr.firstoff.
For layer3 we need to spin the decoder clear, thus actually decode a leading frame before discarding it.


Think about fr.num!

This one needs to be set correctly on seeks. Initially, it is -1. The parser increments this when the next valid frame is read.
When I seek to frame x, I have to set fr.num = x-1.

Now what is the accurate sample position that mpg123_tell() should return?
If fr.num <= fr.firstframe, then

fr.firstframe*spf(fr)+fr.firstoff-fr.begin_s

should be returned.

Else, fr.num could be already served or it will be served when fr.to_decode is set.
So, if fr.to_decode is set; next sample will be

fr.num*spf(fr)-fr.buffer.fill-fr.begin_s

... all samples up to this frame, minus what's still left in buffer.
If to_decode is not set, I have to assume that this frame has been played already: next sample is

(fr.num+1)*spf(fr)-fr.buffer.fill-fr.begin_s

Again, the assumption of spf(fr) being a constant for the stream helps.

Arrg! spf(fr) is the _input_ sample number! I have to separate this from output sample number!
The library does resampling...
Also, I need to get rid of float calculation for samples/bytes conversion, I think.
Though, ntom rate conversion can play tricks.

Simple 2to1 or 4to1 is no problem... It keeps a constant sample number per frame.
The flexible mode is a problem, though.
It's a two-fold problem, even. First, there is the varying number of samples per frame, second, there is the need to set a correct ntom_val for a frame we made a seek to.
Without a correct ntom_val, there will be different samples chosen for output.

So, ntom_val starts at NTOM_MUL>>1 and is incremented by ntom_step for every input sample.
Then, if ntom_val>=NTOM_MUL, it is decremented by NTOM_MUL until it is smaller.
So, for x input sample offset...

ntom_val  = NTOM_MUL>>1 + x*ntom_step
ntom_val -= (ntom_val/NTOM_MUL)*NTOM_MUL

I have to keep an eye on integer limits here... computation has to happen at least with off_t.
But, is it possible to do it in a quick calculation without powering up the multiplication?
Hm... actually, what is ntom_step?

ntom_step = (NTOM_MUL*fr->af.rate)/frame_freq(fr)

Worst case by force is NTOM_MAX*NTOM_MUL, currently

8*32768=262144

Well, it is a number... and the multiple of some sample offset by this is possibly over the limit for the data type.
To help that, I'd have to imitate the (big!) loop that is actually working this out on decoding.
One compromise would be to make it with frames (as decoding will always restart a frame border).

ntom_val  = NTOM_MUL>>1;
for(f=0; f<offset; ++f)
{
	ntom_val += spf(fr)*ntom_step;
	ntom_val -= (ntom_val/NTOM_MUL)*NTOM_MUL;
}

I'm not settled on that yet...
OK, I got ntom_val ... what I need for seeking is a safe computation of sample offset for frame offset.

if(fr->down_sample < 3) soff = (spf(fr)>>fr->down_sample) * fr->num;
else
{
	soff = 0;
	ntom_val = ntom_val(fr,0);
	for(f=0; f<fr->num; ++f)
	{
		ntom_val += spf(fr)*fr->ntom_step;
		soff     += ntom_val/NTOM_MUL;
		ntom_val -= (ntom_val/NTOM_MUL)*NTOM_MUL;
	}
}

The quick and dirty formula for ntom is

soff = (ntom_val(fr,0) + fr->num*spf(fr)*fr->ntom_step)/NTOM_MUL;

Likewise, I need the function the other way round. A sample offset to frame offset and output sample offset in the frame.

   soff*NTOM_MUL = ntom_val(fr,0)+isoff*fr->ntom_step
=> isoff = (soff*NTOM_MUL-ntom_val(fr,0))/fr->ntom_step

That gives me the first input sample that's needed for that offset.
Now I need an input frame from that:

firstframe = isoff/spf(fr)

What is still missing, is the correct number of samples to skip in the output. Since I cannot just convert a number of input samples to a number of output samples (the incremental/recursive nature of the ntom algorithm), I calculate back from the frame to an output sample offset and take a difference:

firstoff = soff - out_sampleoff(firstframe)


Oh... back to gapless: the stored counts of samples to ignore at begin or end... they should be for output, right?

Lemme try to draw the overall picture.

1. I want to set the audio offset to a specific position given in output samples.
2. I need to convert that to input samples to determine the frame offset to set the input data stream to.
   For layer 3, a leading frame will be decoded and discarded to get back on the real track.
3. I want to incorporate the omission of padding and decoder delay, given in input samples.
4. Having determined the correct frame to (re)start decoding from, there is a sample offset left over.
   This offset is in input samples, but must be handled in output samples.
   Here I need to compute the output sample offset of the input frame I've seeked to, then ignoring the difference to the desired output sample offset in the decoder buffer.
5. Actually seek the input stream to some position before the target frame.

The decoding routine watches out for the first frame to decode (considering the frame to ignore, too), decodes it and discards the computet amount of samples, then returns data.
Ideally, that should indeed be the position that has been asked for earlier.

The steps need some tools:
1. mpg132_seek(mh, outs); the API function
2. mpg123_insamples(mh, outs) = ins; convert output sample offset outs to input sample offset ins
   mpg123_frames(mh, ins, &soff) = inf; take ins input sample offset, get the frame offset inf that is just within and also return the input sample offset soff of the beginning of the frame 
   OR
   mpg123_frames(mh,ins) = inf; mpg123_outsamples(mh, inf) = soff;
3. How does the padding/delay offset fit into that picture?
   It is an offset in input samples. The output sample 0 corresponds to input sample begin_s.
   Can I hide that properly inside the sample/frame conversion functions?
   I think I can.
4. mpg123_outsamples(mh, soff) = insoff; The offset in output samples we reached when getting the first decoded data from target frame.
   ignore_samples = ins - soff;
5. back_frame(mh, ...); To wind the input byte stream back/forth ... hm... I want it in absolute terms. This function is a weird one from that perspective...

Hm, for back_frame it doesn't matter if I decoded the frame fr->num already. For the offset I can just use the current fr->num.
Having to construct that offset still looks weird but should not hurt... until I have time to fix that one.

Actually, the splitting of extra insamples/outsamples functions doesn't make sense as the computation of these is bound to frame computation, too.
The conversion is simple as long as we are not dealing with NtoM decoding.
With NtoM, I have

off_t ntom_sampleoff(mpg123_handle *fr, off_t frame);  frame -> output sample offset
off_t ntom_frameoff(mpg123_handle *fr, off_t soff);    output sample offset -> frame

What these should still do is to care for gapless stuff... going to hack that.
Then, the picture is a bit simpler:

1. mpg123_seek(mh, outs)
2. mpg123_set_range(mh, outs) = real_outs; setting firstframe, firstoff, lastframe, lastoff based on gapless data and the demanded offset outs, returning the actually destined output sample position (may differ when gapless code not there, or track is known to be shorter (?))
   -> using ntom_sampleoff() and ntom_frameoff() for NtoM; applying simple formulae for other cases.
3. back_frame(mh, -(fr->ignoreframe-fr->num)); ignoreframe is computed in mpg123_seek, being equal to firstframe or some frame before.

That's the sample seek to an absolute position. What did I forget? Two things:
1. frame seek; that's actually there already ... perhaps nothing to add to that.
2. Seek to an offset from now on. The full function is mpg123_seek(mh, offset, whence).

For the second one I need the current sample position. I compute that trivially using spf(fr) and fr->down_sample for the simple cases and using ntom_sampleoff for NtoM.
So that's mpg123_tell(fr) for you, what I already sketched somewhere...


The gapless bummer

Now, I can be overly smart and consider the dropsamples of gapless on the input side in my calculations, but this is not what happens on decoding!
Currently, the gapless code only works for input and output sample rate being the same.
The NtoM decoding makes trouble here.
I need to convert the begin_s and end_s values to output samples... or... hm... er... yes.
for offsets I need the frame -> outsample, too

ntom_insouts(mh, off_t insamples)
ntom_frmouts(mh, off_t frames)

I need both the input and output sample number in determining firstframe and firstoff.
Also, I should really separate the 3 stages:

input sample offset -> unadjusted output sample offset -> adjusted (gapless) output offset

At least in thought.
I get adjusted output samples from caller. An offset from beginning or _now_, where now is determined in adjusted output samples from mpg123_tell(). Oh, and it could be an offset from the end... where end is guessed by fr->track_frames.
But let's focus on offset from now/beginning.

I have adusted output samples. Make them unadjusted (add fr->begin_os, the converted fr->begin_s).
Then I have samples to talk to the in/out converters; they (the NtoM one...) only consider unadjusted samples.
I compute frame offset and intra-frame sample offset... in unadjusted outsamples, being already what I need.
In case I don't have sample-accurate code (no GAPLESS), the intra-frame sample offset is 0 and I correct the position the caller wanted to the frame boundary; adjustment being a bit unnesessary since the adjustment will be 0 without GAPLESS.

Before doing a seek or even the calculation for begin_os or end_os, I have to be sure that I got the needed decoder variables initialized. That concerns synth_ntom_set_step and the setting of actual output rate.
It means that basically that decode_update must have been run.
So I should take care of that. get_next_frame() actually does so already. It calls decode_update() if something changed in frame format; that is especially true for the first frame of a file.
Now get_next_frame() actually depends on the variables (firstframe, ignoreframe) I need to set _after_ decode_update.
But that should be workable... when it is run for the first time on a track, get_next_frame() will take the first valid one (after Lame tag, even), without seeking or ignoring.
It gets the change, runs decode_update ... there I can convert the gapless stuff to output samples... but what with seek?
Well, get_next_frame() should call the gapless preparation seek before delivering the first frame.

I am with the higher level logic now, lemme walk through the cases:

- A new track is loaded; stuff cleared, firstframe set from parameters, offset=0.
- Either playback happens or seek happens (or loading of another track).
- Playback means that the lame tag will be found, or at least layer 3 will be detected; determining some offsets
  The new (because first) data has to trigger a decode_update and subsequent setting of firstframe & co.
- Seek can happen before or after play.
  Before play it has to make sure that the first frame has been found and decode_update run.
  After play it knows that the first frame has been there and decode_update run.
  Then one can safely (by assumption) set the new first/lastframe and corresponding offsets.

Now I need to keep track of the track's state. A track can be:

- Freshly loaded, virgin, untouched... we don't even know the sample rate yet.
- Initialized, playing... meaning: First frame has been read; lame tag has been read.

Hm... what else? As soon as it's not virgin anymore, it's all the same. We are at some input position, leading some output position.
The format is known, I can compute.


The meaning of fr->num

I should straighten that out... you can be off by one in frame number manipulations easily.
After read_frame(), fr->num contains the frame offset of the frame just read. It's the frame's number.
Since read_frame() increments fr->num on successful read, fr->num should be one less when entering read_frame().
Sounds trivial, but can go wrong when seeking.
You seek to a specific offset (beginning of the frame), want to get the frame for fr->num == offset, you have to set fr->num = offset - 1.
After reading the frame the number is incremented!

This also has some implication for position calculation. When you got that frame fr and wand to tell a current position, you have to look closely:
1. The input stream position is always at fr->num+1.
	When the track is loaded, fr->num = -1; After first frame read, it's 0. 
2. The output position depends on fr->to_decode and the frame output buffer fill
	- fr->to_decode = TRUE  -> output is at samples(fr->num) - fr->buffer.fill (taking sample conversion into account!)
	- fr->to_decode = FALSE -> frame has been decoded; output is at samples(fr->num+1) - fr->buffer.fill 

Before any decoding took place, fr->num == -1 and fr->to_decode = FALSE; so the correct output position is at 0, as is the input position.
